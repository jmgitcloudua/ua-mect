#include <detpic32.h>

volitile unsigned char voltage = 0;

//configure I/O analog input
void configureIO(){
  TRISB = TRISB & 0x80FF; //configure RB14-RB8 as output
  LATB = LATB & 0x80FF; //set initial value
  
  TRISD = TRISD & 0xFF9F; //configure RD6-RD5 as output
  LATB = LATB & 0xFF9F; //set initial value
  
}
//configure A/D module
void configureAD(){
  TRISBbits.TRISB4 = 1;  // Step 1A - RB4 digital output disconnected
    AD1PCFGbits.PCFG4 = 0; // Step 1B - RB4 configured as analog input (AN4)

    AD1CHSbits.CH0SA = 4; // Step 2  - Desired input analog channel (0 to 15)

    AD1CON2bits.SMPI = 3; // Step 3  - 4 samples will be converted and stored
                          // in buffer locations ADC1BUF0 to ADC1BUF3

    AD1CON1bits.SSRC = 7; // Step 4  - Conversion trigger selection bits: in
                          // this mode an internal counter ends sampling and
                          // starts conversion

    AD1CON1bits.CLRASAM = 1; // Step 5 - Stop conversions when the 1st A/D
                             // converter interrupt is generated. At the same
                             // time, hardware clears the ASAM bit

    AD1CON3bits.SAMC = 16; // Step 6 - Sample time is 16 TAD (TAD = 100 ns)

    AD1CON1bits.ON = 1; // Step 7 (see Page 4) - Enable A/D converter
                        // This must the last command of the A/D
                        // configuration sequence
}
//configure Interrupt System
void configADInterruptSys(){
IPC6bits.AD1IP = 2; //configure priority
IFS1bits.AD1IF = 0; //clear A/D
IEC1bits.AD1IE = 1; //enable A/D
}
void delay(int ms){
  for(; ms > 0; ms--){
     resetCoreTimer();
    while(readCoreTimer() < 20000);
 }
}
int _int_(27) isr_adc(void){
  
    int sum = 0, i = 0;
    int *p = (int *) (&ADC1BUF0);
    for(i = 0; i < 8; i++) {
        int value = p[i*4];
        sum += value;
    }
    doubl avarage = (double)sum/8.0; //calculate avarage
    voltage = (char)((avarage*33 + 511)/1023);

   IFS1bits.AD1IF = 0; //reset AD1IF flag
  
}
void send2displays(unsigned char value){
     static const char display7Scodes[] ={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};
    static char displayFlag = 0;
   
  int digit_low = display7Scodes[value & 0x0F];
  int digit_high = display7Scodes[value >> 4];

  if(displayFlag == 0){
     LATDbits.LATD5 = 1;
     LATDbits.LATD6 = 0;
     LATB = (LATB & 0x80FF) | digit_low << 8;
   }else{
     LATDbits.LATD5 = 0;
     LATDbits.LATD6 = 1;  
     LATB = (LATB & 0x80FF) | digit_high << 8;
   }
  
  displayFlag = !displayFlag; //toogle displayFlag vlaue
 
}
unsigned char toBCD(unsigned char value){
 return ((value/10) << 4) +  (value % 10);
}

int main(void){
    int cnt = 0;
    
    configureIO();
    configureAD();
    configADInterruptSys();
    
    EnableInterrupts();//enable global interrrupts

    while(1){
     if(cnt % 25 == 0) //250ms (4 samples/second)
      AD1CON1bits.ASAM = 1; //start convertion
     }
     send2displays(toBCD(voltage & 0xFF)); //send to displays
     cnt++;
     delay(10);//10ms->100Hz
   return 0;
}
