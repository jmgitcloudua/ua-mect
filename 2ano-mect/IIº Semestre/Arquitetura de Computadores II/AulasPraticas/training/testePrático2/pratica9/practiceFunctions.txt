//delay
void delay(int ms){
 for(; ms > 0; ms--){
    resetCoreTimer();
    while(readCoreTimer() < 20000);
 }
}
//toBCD
unsigned char toBCD(unsigned char value){
 return ((value / 10) << 4) + (value % 10);
}
//send2display
void send2display(unsigned char value){
  static const char display7code = {0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71};
  static char displayFlag = 0;

  int digit_low = value & 0xF;
  int digit_hight = value >> 4; 

  if(displayFlag == 0){
    LATB = (LATB & 0x00FF) | display7code[digit_low] << 8;
    LATDbits.LATD5 = 1;
    LATDbits.LATD6 = 0;
  }else{
    LATB = (LATB & 0x00FF) | display7code[digit_high] << 8;
    LATDbits.LATD5 = 0;
    LATDbits.LATD6 = 1;
  }

 displayFlag = !displayFlag;

}
//avarage ADC- exampe 8 sample
void ampAVG_ADC(){
  volatile unsigned char  voltage = 0;
  int sum = 0;
  int  i;
  int *p = (int *)(&ADC1BUF0);
  for(i = 0; i < 8; i++ ){
      int value = p[i*4];
          sum +=value;
  }
    double avg = (double )sum/8.0;
           voltage = (char)(avg*33 + 511)/1023;
   IFS1bits.AD1IF = 0; //reset AD1IF

//**** calling send2display in main:  send2display(toBCD(voltage & 0xFF));
}
//device-driver
#define DisableUart2RxInterrupt() IEC1bits.U2RXIE = 0
#define EnableUart2RxInterrupt() IEC1bits.U2RXIE = 1
#define DisableUart2RxInterrupt() IEC1bits.U2TXIE = 0
#define EnableUart2RxInterrupt() IEC1bits.U2TXIE = 1
#define BUF_SIZE 8
#define TRUE 1
#define FALSE 0
#define INDEX_MASK (BUF_SIZE - 1)
typedef struct {
  unsigend char data[BUF_SIZE];
  unsigend int head;
  unsigend int tail;
  unsigend int count;
} circularBuffer;
volitile circularBuffer txb ;//transmission buffer
volitile circularBuffer rxb ;//reception buffer
//**comDrv_putc
void comDrv_putc(char ch){//TX
   while(txb.count == BUF_SIZE){}//wait while buffer is full
   txb.data[txb.tail] = ch; //copy ch to tx buffer at position 'tail'
   txb.tail = (txb.tail + 1) & INDEX_MASK ; //increment 'tail' index (mod BUF_SIZE)
   DisableUart2TxInterrupt();  //begin of critical section
   txb.count++; //increment 'count' variable
   EnableUart2TxInterrupt(); //end critical section
   
} 
void comDrv_getc(char *pChar){//RX
   if(rxb.count == 0){ //test 'count' variable (rx buffer)
     return FALSE;
   }
   DisableUart2RxInterrupt(); //begin of critical section
   *pChar = rxb.data[rxb.head]; //copy character pointer by 'head' to a pChar
    rxb.count--; //decrement 'count' variable
    rxb.head = (rxb.head + 1) & INDEX_MASK; //increment "head" index (mod BUF_SIZE)
   EnableUart2RxInterrupt(); //end critical section
   return TRUE;
}
voit puts(String *str){
 if(*str != '\0'){
    comDrv_putc(*str);
    str++;
  }
}
void _int_(32) isr_tx(void){
   if(IFS1bits.U2TXIF == 1){
      if(txb.count > 0){
          U2TXREG = txb.data[txb.head];//copy char head to U1TXREG register
          txb.head = (txb.head + 1) & INDEX_MASK; //increment "head" index (mod BUF_SIZE)
          txb.count--; //decrement 'count' variable
       }
     if(txb.count == 0){
         DisableUart2TxInterrupt();
     }
    IFS1bits.U2TXIF = 0; // reset U2TXIF TX interrupt flag
  }
}
void _int_(32) isr_rx(void){
   if(IFS1bits.U2RXIF == 1){
        rxb.data[rxb.tail] = U2TXREG ;// read from UART2 and write to tail
        rxb.tail = (rxb.tail + 1) & INDEX_MASK; //increment "tail" index (mod BUF_SIZE)
      if(rxb.count < BUF_SIZE){
          rxb.count++; //increment 'count' variable
       }
     else{
         rxb.head = (txb.head + 1) & INDEX_MASK;//increment "head" index (mod BUF_SIZE)
     }
    IFS1bits.U2RXIF = 0; // reset U2TXIF RX interrupt flag
  }
}

***********************************************************************************

//Devide driver - all configuration
#define DisableUart2RxInterrupt() IEC1bits.U2RXIE = 0
#define EnableUart2RxInterrupt() IEC1bits.U2RXIE = 1
#define DisableUart2TxInterrupt() IEC1bits.U2TXIE = 0
#define EnableUart2TxInterrupt() IEC1bits.U2TXIE = 1
#define FALSE 0
#define TRUE 1
#define BUF_SIZE 8
#define INDEX_MASK (BUF_SIZE - 1)

typedef struct{
 unsigned char data;
 unsigned int head;
 unsigned int tail;
 unsigned int count;

}circularBuffer;
 volatile circularBuffer rxb;
 volatile circularBuffer txb;

//**comDrv_putc
void comDrv_putc(char ch){//TX
   while(txb.count == BUF_SIZE){}//wait while buffer is full
   txb.data[txb.tail] = ch; //copy ch to a buffer 'tail'
   txb.tail = (txb.tail + 1) & INDEX_MASK; //incremet 'tail' index
   DisableUart2TxInterrupt(); //begin critical section
   txb.count++;//increment 'count' variable
   EnableUart2TxInterrupt();
}
//**comDrv_getc
void comDrv_getc(char *pChar){//RX
   if(rxb.count == 0){
      return FALSE;
   }
   DisableUart2RxInterrupt(); //begin critical section
   *pChar = rxb.data[rxb.head]; //copy char pointer by 'head'  to pChar
    rxb.count--; //decrement 'count' variable
   rxt.head = (rxt.head + 1) & INDEX_MASK; //increment 'head' index
   EnableUart2RxInterrupt();
   return TRUE;
}
//**interruption U2-TX
void _int_(32) isr_tx(void){
  if(IFS1bits.U2TXIF == 1){
       if(txb.count > 0){
           U2TXREG = txb.data[txb.head]; //copy ch head to a U2TXREG register
           txb.head = (txb.head + 1) & INDEX_MASK; // //increment 'head' index
           txb.count--;//decrement 'count' variable
        }
       if(txb.count == 0){
         DisableUart2TxInterrupt();
        }
      IFS1bits.U2TXIF = 0; // reset U2TXIF flag
   }
}
/**interruption U2-RX
void _int_(32) isr_rx(void){
  if(IFS1bits.U2RXIF == 1){
         rxb.data[rxb.tail] = U2TXREG; //read from U2TXREG register and write to 'tail' 
         rxb.tail = (rxb.tail + 1) & INDEX_MASK; // //increment 'tail' index
       if(rxb.count > BUF_SIZE){
           rxb.count++;//increment 'count' variable
        }else){
         rxb.head = (rxb.head + 1) & INDEX_MASK; // //increment 'head' index
        }
      IFS1bits.U2RXIF = 0; // reset U2TXIF flag
   }
}

//config I/O
void configIO(){
  TRISB = (TRISB & 0x80FF); //configure RB14-RB8 as output
  LATB = (LATB & 0x80FF); //set inicial value

  TRISD = (TRISD & 0xF9FF); //configure RB6-RB5 as output
  LATD = (LATD & 0xF9FF); //set inicial value
}

//delay
void delay(int ms){
  for(; ms > 0; ms--){
      resetCoreTimer();
      while(readCoreTimer() < 20000);
   }
}
//toBCD
unsigned char toBCD(unsigned char value){
  return ((value/10) << 4) + (value % 10);
}
//send2display
void send2display(unsigned char value){
  static const char display7code = {};
  static char displayFlag = 0;
 
 int digit_low = value & 0xF;
 int digit_high = value >> 4;

 if(displayFlag == 0){
    LATB = (LATB & 0x00FF) | (display7code[digit_low] << 8) ;
    LATDbits.LATD5 = 1;
    LATDbits.LATD6 = 0;
  }else{
    LATB = (LATB & 0x00FF) | (display7code[digit_high] << 8) ;
    LATDbits.LATD5 = 0;
    LATDbits.LATD6 = 1;
  }

 displayFlag = !displayFlag ;
}
 
//Configure ADC - 8 sample
volatile char voltage = 0;

  int sum = 0;
  int *p = (int *)(&ADC1BUF0);
  for(int i = 0; i < 8; i++){
     int value = p[i*4];
         sum += value;
  }
  double avg = (double)sum/8.0;
     voltage = (char)(avg*33 +  511)/1023;

//**call send2diplay in main
int main(void){
  int cnt = 0;
  //call all function developed here

  //Enable global interrupt here

  while(1){
    if(cnt % 25 == 0){ 250ms(4 sample/second)
      AD1CON1bits.ASAM = 1; //start conervion
     }
  }
  send2diplay(toBCD(voltage) & 0xFF);
  cnt++;
  delay(10); //10ms -> 100Hz
 return 0;
}


********************************************************************************
#include <detpic32.h>

volatile char voltage = 0;

////DEVIDE DRIVER - UART - CIRCULAR BUFFER
#define DesableUart2RxInterrupt() IEC1bits.U2RXIE = 0
#define EnableUart2RxInterrupt() IEC1bits.U2RXIE = 1
#define DesableUart2TxInterrupt() IEC1bits.U2TXIE = 0
#define EnableUart2TxInterrupt() IEC1bits.U2TXIE = 1
#define BUF_SIZE 8
#define INDEX_MASK (BUF_SIZE - 1)
#define FALSE 0
#define TRUE 1

typedef struct{
  unsigned char data;
  unsigned int tail;
  unsigned int head;
  unsigned int count;
} circularBuffer;
volatile circularBuffer rxb;
volatile circularBuffer txb;
void comDrv_flushRx(){
  rxb.tail = 0;
  rxb.head = 0;
  rxb.count = 0;
}
void comDrv_flushTx(){
  txb.tail = 0;
  txb.head = 0;
  txb.count = 0;
}
//***comDrv_putc
void comDrv_putc(char ch){//TX
  while(txb.count == BUF_SIZE);//wait while BUF is full
  txb.data[txb.tail] = ch; 
  txb.tail = (txb.tail) & INDEX_MASK;
  DesableUart2TxInterrupt();
  txb.count++;
  EnableUart2TxInterrupt();
}
//*** comDrv_getc
void comDrv_getc(char *pChar){
  if(rxb.count == 0){
     return FALSE;
   }
    DesableUart2RxInterrupt();
    *pChar = rxb.data[rxb.head];
     rxb.count--;
     rxb.head = (rxb.head + 1) & INDEX_MASK;
     EnableUart2RxInterrupt();
    return TRUE;
}
void puts(String *s){
 if(*s != '\0){
   comDrv_putc(*s);
   s++;
  }
}
//***Interrupt System - TX - UART2
void _int_(32) isr_tx(void){
 if(IFS1bits.UTXIF == 1){
    U2TXREG = txb.data[txb.head];
    txb.head = (txb.head + 1) & INDEX_MASK;
    txb.count--;
    if(txb.count == 0){
         DesableUart2RxInterrupt();
    }
    IFS1bits.UTXIF = 0;
  }
}
//***Interrupt System - RX - UART2
void _int_(32) isr_rx(){
  if(IFS1bits.URXIF == 1){
    rxb.dada[rxb.tail] =  U2RXREG;
    rxb.tail = (txb.tail + 1) & INDEX_MASK;
    if(rxb.cout > BUF_SIZE){
     rxb.count++;
    }else{
    rxb.head = (txb.head + 1) & INDEX_MASK;
    }
    IFS1bits.URXIF = 0;
  }
}

//**delay
void delay(int ms){
  for(; ms > 0; ms--){
    resetCoreTimer();
    while(readCoreTimer() < 20000);
  }
}
//**toBCD
unsigned char toBCD(unsigned char value){
 return ((value / 10) << 4) + (value % 10);
}


//**send2display
void send2display(unsigned char value){
   static cons char display7seg = {};
   static char displayFlag = 0;
   
   int digit_low = value & 0x0F;
   int digit_high = value >> 4;

  if(displayFlag == 0){
     LATBbits.LATB5 = 0;
     LATB = (LATB & 0x00F) | (display7seg[digit_low] << 8);
     LATBbits.LATB6 = 1;
  }else{
     LATBbits.LATB5 = 1;
     LATB = (LATB & 0x00F) | (display7seg[digit_low] << 8);
     LATBbits.LATB6 = 0;
  }
 displayFlag = !displayFlag;
}
//**Calculate ADC AGV - 8 samples
  int sum = 0;
  int *p = (int *)&(ADC1BUF0);
  for(int i = 0; i < 8 i++){
    int value = p[i*4];
       sum += value;
  }
  double avg = (double)sum/8.0;
      voltage = (char)(avg*33 + 511)/1023;
//call send2display in main
int main(void){
  
   int cnt = 0;
  
  //call config here

  //enable global interrupts here

 while(1){
   if(cnt % 25 == 0){
     AD1CON1bits.ASAM = 1; //start convertion
    }
  }
  send2display(toBCD(voltage) & 0xFF);
  cnt++;
  delay(10);//100Hz->10ms

 return 0;
}



***********************************************************

#include <detpic32.h>

#define DesableUart1RxInterrupt() IEC0bits.U1RXIE = 0
#define EnableUart1RxInterrupt() IEC0bits.U1RXIE = 1
#define DesableUart1TxInterrupt() IEC0bits.U1TXIE = 0
#define EnableUart1TxInterrupt() IEC0bits.U1TXIE = 1
#define BUF_SIZE 32
#define INDEX_MASK (BUF_SIZE - 1)
#define FLASE 0
#define TRUE 1

typedef struct{
 unsigned char data[BUF_SIZE];
 unsigned int head;
 unsigned int tail;
 unsigned int count;
}circularBuffer;
 volatile circularBuffer rxb;
 volatile circularBuffer txb;

void comDrv_flushRx(){
 //initialize RX
 rxb.head = 0;
 rxb.tail = 0;
 rxb.count = 0;
}
void comDrv_flushTx(){
 //initialize TX
 txb.head = 0;
 txb.tail = 0;
 txb.count = 0;
}
void comDrv_putc(char ch){//TX
 while(txb.count == BUF_SIZE){}
 txb.data[txb.tail] = ch;
 txb.tail = (txb.tail + 1) & INDEX_MASK;
 DesableUart1TxInterrupt();
 txb.count++;
 EnableUart1TxInterrupt()
}
void comDrv_getc(char *pChar){//RX
 if(rxb.count == 0){
   return FALSE;
  }
   DesableUart1RxInterrupt();
  *pchar = rxb.data[rxb.head];
   rxb.count--;
   rxb.head = (rxb.head + 1) & INDEX_MASK;
   EnableUart1RxInterrupt()
   return TRUE;
}
void _int_(24) isr_uart1(){
  //TX
  if(IFS0bits.U1TXIF == 1){
      U1TXREG = txb.data[txb.head];
      txb.head = (txb.head + 1) & INDEX_MASK;
      txb.count--;
       if(txb.count == 0){
         DesableUart1TxInterrupt();
        }
      IFS0bits.U1TXIF = 0;
   }

  //RX
   if(IFS0bits.U1RXIF == 1){
        rxb.data[rxb.tail] = U1RXREG ;
        rxb.tail = (rxb.tail + 1) & INDEX_MASK;
        if(rxb.count > BUF_SIZE){
           txb.count++;
        }else{
          rxb.head = (rxb.head + 1) & INDEX_MASK;
        }
      IFS0bits.U1RXIF = 0;
   }

}

*****************************************************************


void comDrv_putc(chae ch){//TX
 while(txb.count == BUF_SIZE){}
  txb.data[txb.tail] = ch;
  txb.tail = (txb.tail + 1) & INDEX_MASK
  DesableUart1TxInterrupt();
  txb.count++;
  EnableUart1TxInterrupt();
}
void comDrv_getc(char *pChar){//RX
  if(rxb.count == BUF_SIZE){
    return FALSE;
  }
  DesableUart1RxInterrupt();
  *pChar = rxb.data[rxb.head];
   rxb.count--;
  rxb.head = (txb.head + 1) & INDEX_MASK
   EnableUart1RxInterrupt();
  return TRUE;
}
void _int_(24) isr_uart1(){
  //TX
  if(IFS0bits.U1TXIF == 1){ 
     U1TXREG = txb.data[txb.head];
     txb.head = (txb.head + 1) & INDEX_MASK
     txb.count--;
    if(txb.count == 0){
       DesableUart1TxInterrupt();
     }
     IFS0bits.U1TXIF = 0;
   }

 //RX
 if(IFS0bits.U1RXIF == 1){ 
     rxb.data[rxb.tail] = U1RXREG ;
     rxb.tail = (txb.tail + 1) & INDEX_MASK;
     if(rxb.count > BUF_SIZE){
      rxb.count++;
    }else{
     rxb.head = (rxb.head + 1) & INDEX_MASK
   }
   IFS0bits.U1RXIF = 0;
 }   
}





























































