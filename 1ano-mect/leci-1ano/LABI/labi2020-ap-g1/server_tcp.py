#!/usr/bin/python3

import random
import sys
import socket
import select
import json
import base64
from Crypto.Hash import SHA256
from Crypto.Cipher import AES

from common_comm import send_dict, recv_dict, sendrecv_dict

procs = {}

#
# Handler do pedido de criação de um processo de ordenação
#
def new_process( process_id, sock ):

    if process_id in procs.keys():
        return { 'error':'Sorting process already exists' }
    else:
        procs[process_id] = { 'endpoint': sock, 'ids': {} } 
        return { 'error' : "" }

#
# Handler do pedido de inclusão de um novo candidato no processo de ordenação
#
def new_client( process_id, client_id, sock ):

    if process_id in procs:
        proc = procs[process_id]  # Selected sorting process

        if client_id in proc['ids']: # Client already belongs to it
            return { 'error':'Client already registered in sorting process' }
        else:                        # New client
            proc['ids'][client_id] = { 'endpoint': sock }
            return { 'error':'' }

    else:
        return { 'error':'Sorting process not found' }

#
# Handler do pedido de listagem de clientes inscritos num processo de ordenação
#
def list_clients( process_id, sock ):
    if process_id in procs:
        proc = procs[process_id]  # Selected sorting process

        ids = []
        for i in proc['ids']:
            ids.append( i )
        return { 'ids':ids, 'error':'' }
    else:
        return { 'error':'Sorting process no found' }

#
# Handler do pedido de inicio da ordenação
#
def start_sorting( process_id, sock ):
    if process_id not in procs.keys():
        return { 'error':'Sorting process not found' }
    else:
        proc = procs[process_id]     # Selected sorting process
        if sock != proc['endpoint']: # Registered address is not the requester
            return { 'error':'Not authorized, you are not the process manager' }
        else:
            return run_sorting( proc )

def clean_proc( process_id ):
    clients = procs[process_id]['ids']

    for c in clients.values():
        c['endpoint'].close()

    del(procs[process_id])

def dump_proc( process_id ):
    dump_dict = {'proc_id': process_id, 'ids': {}}

    for client_id in procs[process_id]['ids']:
        order = procs[process_id]['ids'][client_id]['order']
        c_id = client_id
        C = procs[process_id]['ids'][client_id]['Ci']
        K = procs[process_id]['ids'][client_id]['Ki']
        B = procs[process_id]['ids'][client_id]['Bi']
        dump_dict['ids'].update({c_id: {'order': order, 'C': C, 'K': K, 'B': B}})

    return dump_dict

def clean_client ( sock ):
    for k,v in procs.items():
        if v['endpoint'] == sock:
            clean_proc ( k )
            return

#
# Processo de ordenação
#
def run_sorting( proc ):
    lst = []  # List of numbers that are going to the clients

    def getList(dict):  # Returns a list with all ids connected to the server
        return list(dict.keys())  # Makes a list out of dictionary keys (users id's)
    clients_list = getList(proc['ids'])

    #  Step 1
    #  Creates the List with numbers from 1 to N
    for index in range(1, len(clients_list) + 1):
        lst.append(str(base64.b64encode(bytes("%16s" % index, 'utf-8')), 'utf-8'))

    #  Step 2 & 3
    #  Sends the list to one of the client and receives a list Cyphered by him
    lista = {'lst': lst}
    for i in range( len(clients_list) ):
        socket_list = proc['ids'][clients_list[i]]['endpoint']  # Contains socket information used to get the client's "adress"
        lista = sendrecv_dict( socket_list, lista)  # Receives the list ciphered by N users N times
    assert len(clients_list) == len(lista['lst'])

    #  Step 4
    #  Sends the list troughout all users and removes 1 element at a time
    for i in range( len(clients_list) ):
        socket_list = proc['ids'][clients_list[i]]['endpoint']  # Contains socket information used to get the client's "adress"
        lista = sendrecv_dict( socket_list, lista)  # Receives the list empty
    assert len(lista['lst']) == 0

    #  Step 5
    #  Receives the Cypher chosen and bit commitment from the clients
    Ci_list = []
    Bi_list = []
    for i in range( len(clients_list) ):
        socket_list = proc['ids'][clients_list[i]]['endpoint']  # Contains socket information used to get the client's "adress"
        Ci = recv_dict( socket_list )  # Receives the Cipher chosen by the client
        Ci_list.append( Ci['C'] )
        proc['ids'][clients_list[i]]['Ci'] = Ci['C']
        Bi = recv_dict( socket_list )  # Receives the Bit Commitment generated by the client
        proc['ids'][clients_list[i]]['Bi'] = Bi['B']
        Bi_list.append( Bi['B'] )


    #  Step 6
    #  Associating the client name with the (Cypher chosen, Bit Commitment) pair
    Pairs = {}
    for i in range( len(clients_list) ):
        Pairs[clients_list[i]] = {"Ci": Ci_list[i], "Bi": Bi_list[i]}

    for i in range(len(clients_list)):
        socket_list = proc['ids'][clients_list[i]]['endpoint']  # Contains socket information used to get the client's "adress"
        connected = sendrecv_dict( socket_list, Pairs )
        # Checking if any client has left uppon verifying the Pair's vericity
        if connected['con'] == 0:
            sys.exit("ERROR: Client disconnected")


    #  Step 7
    #  Asking the clients their keys
    keys = []  # List with ALL users keys

    for i in range( len(clients_list)):
        socket_list = proc['ids'][clients_list[i]]['endpoint']  # Contains socket information used to get the client's "adress"
        key = recv_dict( socket_list )
        keys.append( key['key'] )
        Pairs[clients_list[i]]['key'] = key['key']
        proc['ids'][clients_list[i]]['Ki'] = key['key']


    #  Step 8
    #  Sending Pairs to ALL clients (updated with the key value)
    for i in range( len(clients_list) ):
        socket_list = proc['ids'][clients_list[i]]['endpoint']  # Contains socket information used to get the client's "adress"
        connected = sendrecv_dict( socket_list, Pairs )  # Gives to ALL users the list of everyone's keys
        # Checking if any client has left uppon verifying the Pair's vericity
        if connected['con'] == 0:
            sys.exit("ERROR: Client disconnected")

    #  Reverse the keys
    keys.reverse()
    ClientNumber = {}
    #  Sending ALL the keys to ALL clients (keys are in reverse order)
    for i in range( len(clients_list) ):
        socket_list = proc['ids'][clients_list[i]]['endpoint']  # Contains socket information used to get the client's "adress"
        order = sendrecv_dict(socket_list, {'reversedKeys': keys})  # Gives to ALL users the list of everyone's keys
        ClientNumber.update({clients_list[i]: order['order']})
        proc['ids'][clients_list[i]]['order'] = order['order']

    #  Verifying if there are repeated numbers
    for i in range(len(ClientNumber)):
        for j in range(i+1, len(ClientNumber)):
            if ClientNumber[clients_list[i]] == ClientNumber[clients_list[j]]:
                sys.exit("ERROR: 2 clients have the same order")


    #  Step 9
    for i in range( len(clients_list) ):
        socket_list = proc['ids'][clients_list[i]]['endpoint']  # Contains socket information used to get the client's "adress"
        connected = sendrecv_dict(socket_list, ClientNumber)  # Gives to ALL users the list of everyone's keys
        # Checking if any client has left uppon verifying the Pair's vericity
        if connected['con'] == 0:
            sys.exit("ERROR: Client disconnected")

    return

#
# Message structure:
# { op: NEW, proc: proc_id }
# { op: ADD, proc = proc_id, id: client_id }
# { op: LIST, proc: proc_id }
# { op: START, proc: proc_id }d
#

#2nd a correr

def new_msg( client ):
    request = recv_dict( client )
    print( 'Command: %s' % (str(request)) )

    if request['op'] == 'NEW':     # Create a new sorting process
        resp = new_process( request['proc'], client )
    elif request['op'] == 'ADD':   # Add a client to a sorting process
        resp = new_client( request['proc'], request['id'], client )
    elif request['op'] == 'LIST':   # List clients in a sorting process
        resp = list_clients( request['proc'], client )
    elif request['op'] == 'START': # Start the sorting process
        start_sorting( request['proc'], client )
        resp = dump_proc( request['proc'] )
        clean_proc( request['proc'] )
    else:
        resp = { 'error':'Wrong request "' + request['op'] + '"' }

    send_dict( client, resp )

#Primeiro a correr

def main():
    # Validate the program parameters (python's program name + server port)
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        sys.exit("ERROR: Invalid parameters <server port> <optional server ip>")

    #If the program has 3 arguments, make the last one the server's ip
    if len(sys.argv) == 3:
        try:
            ip = str(sys.argv[2])
            x = ip.split(".")

            #Verify that the 3rd argument has an IPv4 or DNS structure
            if len(x) != 2 and len(x) != 4:
                raise Exception("Server adress is not a valid IPv4 or DNS")

            #Verify if the DNS structure contains blank parameters as (google.) or (.com)
            if len(x) == 2:
                for i in x:
                    if i == '':
                        raise Exception("DNS not valid")

            #Verify the IPv4 structure is valid (X.X.X.X), X is a number between 0 and 255
            if len(x) == 4:
                for i in x:
                    if int(i) < 0 or int(i) > 255:
                        raise Exception("IPv4 (X.X.X.X) is not valid, X must be a int between 0 and 255")
        except Exception as err:
            sys.exit("ERROR: " + str(err))
    else:
        ip = "127.0.0.1"

    # Set the server's TCP address from the command args
    try:  #Verify if the server port is valid
        address = ( ip , int(sys.argv[1]) )
        if int(sys.argv[1]) < 999:
            raise ValueError("Server port must be a positive number with at least 4 digits")
    except ValueError as err:
        sys.exit("ERROR: " + str(err))

    s = socket.socket( socket.AF_INET, socket.SOCK_STREAM )
    s.bind( address )
    s.listen()

    clients = []
    
    while True:
        try:
            available = select.select( [ s ] + clients, [], [] )[0]
        except ValueError:
            # Sockets may have been closed, check for that
            for c in clients:
                if c.fileno() == -1: # closed
                    clients.remove( c )
            continue # Reiterate select

        for c in available:
             # New client?
             if c is s:
                new, addr = s.accept()
                clients.append( new )
             # Or a client
             else:
                # See if client sent a message
                if len(c.recv( 1, socket.MSG_PEEK )) != 0:
                    new_msg( c )
                else: # or just disconnected
                    clients.remove( c )
                    clean_client( c )
                    c.close()
                    break # Reiterate select

if __name__ == "__main__":
    main()